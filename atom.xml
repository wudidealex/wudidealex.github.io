<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lcdzzz的博客</title>
  
  <subtitle>等待白鸽飞出</subtitle>
  <link href="http://lcdzzz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lcdzzz.github.io/"/>
  <updated>2021-01-18T14:12:11.009Z</updated>
  <id>http://lcdzzz.github.io/</id>
  
  <author>
    <name>lcdzzz</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java笔记</title>
    <link href="http://lcdzzz.github.io/2021/01/18/java-bi-ji/"/>
    <id>http://lcdzzz.github.io/2021/01/18/java-bi-ji/</id>
    <published>2021-01-18T14:11:16.357Z</published>
    <updated>2021-01-18T14:12:11.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ol><li><p>super是一个关键字，全部小写</p></li><li><p>super和this对比着学习</p><p>this：</p><ul><li><p>能出现在实例方法和构造方法中</p></li><li><p>语法是”this.” 、 “this()”</p></li><li><p>this不能出现在静态方法中</p></li><li><p>大部分条件下是可以省略的</p></li><li><p>this.什么时候不能省略呢？</p><p>在区分局部变量和实例变量的时候不能省略。</p><p>public void setName(string name){</p><p>​    this.name=name;</p><p>}</p><p>this()只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中其他的构造方法，目的是：代码复用。</p></li></ul><p>super：</p><ul><li><p>能出现在实例方法和构造方法中</p></li><li><p>语法是”super.” 、 “super()”</p></li><li><p>super不能出现在静态方法中</p></li><li><p>大部分条件下是可以省略的</p></li><li><p>super.什么时候不能省略呢？？？？？</p><p>在区分局部变量和实例变量的时候不能省略。</p><p>super（)只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中其他的构造方法，目的是：创建子类对象的时候，先初始化父类型特征</p></li></ul></li><li><p>super()</p><p>表示通过子类的构造方法调用父类的构造方法。</p><p>模拟现实世界中：要想要儿子，必须先有父亲。</p><p>//一个类如果没有手动提供任何构造方法，系统会默认提供一个无参数构造方法。</p><p>//一个类如果手动提供了一个构造方法，那么无参数构造方法系统将不会再提供。</p></li><li><p>重要结论：</p><p>当一个构造方法第一行：</p><p>既没有this（）又没有super（）的话，默认会有一个super（）；</p><p>表示通过当前子类的构造方法调用父类的无参数构造方法。</p><p>所以必须保证父类的无参数构造方法是存在的。</p></li><li><p>注意：</p><p>this()和super()不能共存，他们都是只能出现在构造方法的第一行。</p></li><li><p>无论怎么折腾，父类的构造方法是一定会执行的（100%）。</p><p>//在java语言中不管是new什么对象。最后老祖宗的object类的无参数构造方法一定会执行（object类的无参数构造方法是处于“栈顶部”）</p><p>栈顶的特点：</p><p>最后调用，但最先执行结束。</p><p>后进先出原则</p><p>以后写代码的时候，一个类的无参数构造方法还是建议手动写出来。</p><p>如果无参数构造方法丢失的话，可能会影响到子类对象的构建</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;super关键字&quot;&gt;&lt;a href=&quot;#super关键字&quot; class=&quot;headerlink&quot; title=&quot;super关键字&quot;&gt;&lt;/a&gt;super关键字&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;super是一个关键字，全部小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sup</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常见的DOS命令</title>
    <link href="http://lcdzzz.github.io/2021/01/18/chang-jian-de-dos-ming-ling/"/>
    <id>http://lcdzzz.github.io/2021/01/18/chang-jian-de-dos-ming-ling/</id>
    <published>2021-01-18T07:22:04.169Z</published>
    <updated>2021-01-18T07:24:43.657Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>打开DOS命令窗口：</p><p>开始菜单–&gt;运行–&gt;输入cmd–&gt;回车/win+r</p></li><li><p>常见的DOS命令：</p><ol><li><p>cls 清屏。</p></li><li><p>DOS窗口怎么复制：选中复制内容后在任意位置点击鼠标右键，此时内容已经在剪切板了。</p></li><li><p>dir 列出当前目录下所有的子文件/子目录。</p></li><li><p>cd 命令</p><ul><li><p>cd命令表示：change directory。</p></li><li><p>怎么用：cd 目录的路径。</p></li><li><p>cd.. 回到上级目录。</p></li><li><p>cd\ 直接回到根目录。</p></li><li><p>怎么切换盘符：</p><p>d:回车。</p></li></ul></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开DOS命令窗口：&lt;/p&gt;
&lt;p&gt;开始菜单–&amp;gt;运行–&amp;gt;输入cmd–&amp;gt;回车/win+r&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的DOS命令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;cls 清屏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DOS窗口怎么</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>acm部分做题记录</title>
    <link href="http://lcdzzz.github.io/2020/11/28/acm-bu-fen-zuo-ti-ji-lu/"/>
    <id>http://lcdzzz.github.io/2020/11/28/acm-bu-fen-zuo-ti-ji-lu/</id>
    <published>2020-11-28T13:18:55.888Z</published>
    <updated>2020-11-30T08:17:11.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="acm做题部分记录"><a href="#acm做题部分记录" class="headerlink" title="acm做题部分记录"></a>acm做题部分记录</h1><h2 id="hdoj-2036改革春风吹满地"><a href="#hdoj-2036改革春风吹满地" class="headerlink" title="hdoj 2036改革春风吹满地"></a>hdoj 2036改革春风吹满地</h2><ul><li>简述：（变成一般问题的话）一个多边形告诉你边数（定点数）为n，然后是按照逆时针顺序给出的n个顶点的坐标（x1, y1, x2, y2… xn, yn），然后求他的面积。</li></ul><p>这题最简单最快的方法就是叉乘法（原理不懂不要紧，记住公式，反正很容易记）</p><p>部分代码实现</p><blockquote><pre><code>   for (int i = 0; i &lt; n; i++) &#123;                int t = i + 1;                if (t == n) &#123;                    t = 0;                &#125;                s = s+(a[i] * b[t] - a[t] * b[i])/2.0;            &#125;</code></pre></blockquote><p>这当中，数组a代表x坐标，数组b代表y坐标，从i=0（第一个点）叉乘到i=n-1（最后一个点）</p><p>这些点是逆时针顺序的，如果是顺时针，那么求出来的值是负数，就要在前面加一个绝对值<code>Math.abs</code></p><p>上面代码翻译成数学就是:</p><p>s = [（x1 * y2 - x2 * y1）+（x2 * y3 - x3 * y2) + ….. + (x(n - 2) * y(n - 1)-x(n - 1) * y(n - 2))+(x(n-1) * y0 - x0 * y(n-1)) ]/2.0</p><p>接下来就是喜闻乐见的整体代码</p><blockquote><pre><code>   import java.util.Scanner;   public class Main &#123;        public static void main(String[] args) &#123;            Scanner in = new Scanner(System.in);            while (in.hasNext()) &#123;                int n = in.nextInt();                if (n == 0) &#123;                    break;        &#125;        int  [] a = new int [n];        int  [] b = new int [n];        for (int i = 0; i &lt; n; i++) &#123;            a[i] = in.nextInt();            b[i] = in.nextInt();        &#125;        double s = 0;        for (int i = 0; i &lt; n; i++) &#123;            int t = i + 1;            if (t == n) &#123;                t = 0;            &#125;            s = s+(a[i] * b[t] - a[t] * b[i])/2.0;        &#125;        System.out.println(Math.abs(s));    &#125;&#125;</code></pre><p>}</p></blockquote><h2 id="hdoj2045动态规划"><a href="#hdoj2045动态规划" class="headerlink" title="hdoj2045动态规划"></a>hdoj2045动态规划</h2><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2045"></a></p><p>【动态规划】:把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，<br>逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p><ul><li><p>思路：设f(n)代表当有n个方格时，满足条件的涂法</p><p>易知：f(1)=3;f(2)=6; f(3)=6;</p><ul><li>假设第n-1个格子的颜色跟第1个相同，<br> 因为第n-1个格子颜色已确定，第n个格子可以涂的颜色有两种，<br> 故为2*f(n-2)</li></ul><p>​                    怎么理解:    以n=4时为例</p><ul><li><u>R G</u> R (P/G) 下划线两个，代表f(2),因为在第1个和第3个相同，所以相当于第3个也已经确定了 。所以是f(2)*2</li><li><u>R G P</u> (G)  下划线三个，代表f(3),因为第1个和第3个不同，留个第4位的只有一个选择了，所以是f(3)*1</li></ul></li><li><p>答案：</p></li></ul><p>​      </p><blockquote><pre><code>   import java.util.Scanner;   public class Main &#123;       public static void main(String[] args) &#123;           long [] a =new long [51];           a[1]=3;           a[2]=6;           a[3]=6;           for(int i=4;i&lt;=50;i++)           &#123;               a[i]=a[i-1]+2*a[i-2];           &#125;          Scanner in  = new Scanner(System.in);           while(in.hasNext()) &#123;              int n=in.nextInt();               System.out.println(a[n]);           &#125;           &#125;       &#125;</code></pre></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;acm做题部分记录&quot;&gt;&lt;a href=&quot;#acm做题部分记录&quot; class=&quot;headerlink&quot; title=&quot;acm做题部分记录&quot;&gt;&lt;/a&gt;acm做题部分记录&lt;/h1&gt;&lt;h2 id=&quot;hdoj-2036改革春风吹满地&quot;&gt;&lt;a href=&quot;#hdoj-2036</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java语法随记</title>
    <link href="http://lcdzzz.github.io/2020/11/25/java-yu-fa-sui-ji/"/>
    <id>http://lcdzzz.github.io/2020/11/25/java-yu-fa-sui-ji/</id>
    <published>2020-11-25T11:59:11.214Z</published>
    <updated>2020-12-01T07:09:13.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-math-BigDecimal的用法"><a href="#java-math-BigDecimal的用法" class="headerlink" title="java.math.BigDecimal的用法"></a>java.math.BigDecimal的用法</h2><ol><li><p>BigDecimal类型用来存储金额等有小数，需要精度的数据</p></li><li><p>BigDecimal不能直接使用int类型赋值！</p></li><li><p>两种使BigDecimal初始化为0的方法:<br>BigDecimal a=BigDecimal<br>BigDecimal b=new BigDecimal(0);<br>BigDecimal a = in.nextBigDecimal();</p><ul><li>除法运算：</li></ul><p>​      <code>System.out.println(new BigDecimal(153.5).divide(new BigDecimal(100), 2, BigDecimal.ROUND_HALF_UP));</code></p><p>　  //new BigDecimal(100)除数，2精确的位数，BigDecimal.ROUND_HALF_UP：舍入模式</p><ul><li><p>加法运算：</p><p><code>System.out.println(new BigDecimal(&quot;2.005&quot;).add(new BigDecimal(&quot;0.03&quot;)));</code></p></li><li><p>减法运算：</p><p><code>System.out.println(new BigDecimal(&quot;2.00&quot;).subtract(new BigDecimal(&quot;1.10&quot;)));</code></p></li><li><p>乘法运算：</p><p><code>System.out.println(new BigDecimal(&quot;2.05&quot;).multiply(new BigDecimal(&quot;10&quot;)));</code></p></li></ul></li></ol><h2 id="char-SS-s-toCharArray"><a href="#char-SS-s-toCharArray" class="headerlink" title="char [] SS = s.toCharArray();"></a>char [] SS = s.toCharArray();</h2><ul><li><p><code>char [] SS = s.toCharArray();</code></p><p>//把字符串中的每个字符放进ss的字符数组里</p></li></ul><h2 id="s-contains-“4”-s-contains-“62”"><a href="#s-contains-“4”-s-contains-“62”" class="headerlink" title="s.contains(“4”)||s.contains(“62”)"></a>s.contains(“4”)||s.contains(“62”)</h2><ul><li><p><code>(s.contains(&quot;4&quot;)||s.contains(&quot;62&quot;)</code></p><p>//判断s字符串里有没有包含”4”或”62”</p></li></ul><h2 id="java自定义函数调用"><a href="#java自定义函数调用" class="headerlink" title="java自定义函数调用"></a>java自定义函数调用</h2><h3 id="一：主类中的自定义函数"><a href="#一：主类中的自定义函数" class="headerlink" title="一：主类中的自定义函数"></a>一：主类中的自定义函数</h3><p>在主类中，如果想要在main函数中调用自定义的其他方法，则这个函数需要使用<u>static关键字</u>定义，否则会报错Cannot make a static reference to the non-static method xx from the type xx，调用的时候<u>直接用函数名</u>就可以了，如下：</p><blockquote><pre><code>   public class create_function &#123;      public static void main(String []args)&#123;　　   int s = jia(5,4);            System.out.println(s);        &#125;        static int jia(int a, int b)&#123;            System.out.println(&quot;我是自定义相加函数，我被调用了！！&quot;);            return a+b;        &#125;                 &#125;     </code></pre></blockquote><p>下面使用static关键字定义了一个“+”运算的函数，在main中调用时，直接使用函数名，括号中加参数就可以了。输出结果如下：</p><p>​        我是自定义相加函数，我被调用了！！<br>​        9</p><h3 id="二：自定义类中函数的调用"><a href="#二：自定义类中函数的调用" class="headerlink" title="二：自定义类中函数的调用"></a>二：自定义类中函数的调用</h3><p>自定义类中函数的调用有两种情况，静态函数和非静态函数，<u>非静态函数的调用需要先声明一个类实例，通过实例调用</u>。静态函数的调用可以通过实例，也可以直接使用类名调用(建议使用这种，要不会造成内存空间的浪费。)，如下：</p><blockquote><pre><code>   public class create_function &#123;       public static void main(String []args)&#123;           Y y =new Y();           int s2 = y.cheng(3,5);//声明了y这个实例           System.out.println(s2);//直接用Y这个类调用           int s3 = Y.chu(8, 2);           System.out.println(s3);       &#125;    &#125;   class Y&#123;       int cheng(int a,int b)&#123;           System.out.println(&quot;我是自定义类中的乘方法，我被调用了！&quot;);           return a*b;       &#125;       static int chu(int c,int d)&#123;          System.out.println(&quot;我是自定义类中的除方法，我被调用了！&quot;);           return c/d;       &#125;   &#125;</code></pre></blockquote><p>在下面，自定义了一个Y类，cheng方法是非静态方法，必须通过实例y调用，chu方法是静态方法，使用类名直接调用。输出结果如下：</p><p>​        我是自定义类中的乘方法，我被调用了！<br>​        15<br>​        我是自定义类中的除方法，我被调用了！<br>​        4</p><h2 id="String-valueOf-方法的使用"><a href="#String-valueOf-方法的使用" class="headerlink" title="String.valueOf()方法的使用"></a>String.valueOf()方法的使用</h2><h3 id="一：由基本数据形态转换成String"><a href="#一：由基本数据形态转换成String" class="headerlink" title="一：由基本数据形态转换成String"></a>一：由基本数据形态转换成String</h3><p>String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 ，也就是 <strong>String.valueOf()</strong> 这个参数多载的方法 ：</p><p>（1）<strong>String.valueOf(boolean b)</strong> : 将 boolean 变量 b 转换成字符串<br>（2）<strong>String.valueOf(char c)</strong> : 将 char 变量 c 转换成字符串<br>（3）<strong>String.valueOf(char[] data)</strong> : 将 char 数组 data 转换成字符串<br>（4）<strong>String.valueOf(char[] data, int offset, int count)</strong> : 将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 </p><p>（5）<strong>String.valueOf(double d)</strong> : 将 double 变量 d 转换成字符串<br>（6）<strong>String.valueOf(float f)</strong> : 将 float 变量 f 转换成字符串<br>（7）<strong>String.valueOf(int i)</strong> : 将 int 变量 i 转换成字符串<br>（8）<strong>String.valueOf(long l)</strong> : 将 long 变量 l 转换成字符串<br>（9）<strong>String.valueOf(Object obj)</strong> : 将 obj 对象转换成 字符串, 等于 obj.toString() </p><p>　　<strong>用法如下:</strong><br>　　<code>int i = 10;</code><br>　　<code>String str = String.valueOf(i);</code><br>　　这时候 str 就会是 “10” </p><h3 id="二、-由-String-转换成-数字的基本数据型态"><a href="#二、-由-String-转换成-数字的基本数据型态" class="headerlink" title="二、 由 String 转换成 数字的基本数据型态"></a><strong>二、 由 String 转换成 数字的基本数据型态</strong></h3><p>要将 String 转换成基本数据型 ，大多需要使用基本数据型态的包装类别 </p><p>（1） <strong>Byte.parseByte(String s)</strong> : 将 s 转换成 byte </p><p>（2）<strong>Byte.parseByte(String s, int radix)</strong> : 以 radix 为基底（进制基数） 将 s 转换为 byte ，比如说 Byte.parseByte(“11”, 16) 会得到 17。</p><p>（3） <strong>Double.parseDouble(String s)</strong> : 将 s 转换成 double </p><p>（4） <strong>Double.parseFloat(String s)</strong> : 将 s 转换成 float </p><p>（5） <strong>Integer.parseInt(String s)</strong> : 将 s 转换成 int </p><p>（6） <strong>Long.parseLong(String s)</strong> : 将 s 转换成 long</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java-math-BigDecimal的用法&quot;&gt;&lt;a href=&quot;#java-math-BigDecimal的用法&quot; class=&quot;headerlink&quot; title=&quot;java.math.BigDecimal的用法&quot;&gt;&lt;/a&gt;java.math.BigDeci</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git bash部分命令行的操作</title>
    <link href="http://lcdzzz.github.io/2020/11/25/git-bash-bu-fen-ming-ling-xing-de-cao-zuo/"/>
    <id>http://lcdzzz.github.io/2020/11/25/git-bash-bu-fen-ming-ling-xing-de-cao-zuo/</id>
    <published>2020-11-24T16:15:47.063Z</published>
    <updated>2020-11-24T16:18:53.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用git-bash-创建文件及文件夹命令"><a href="#使用git-bash-创建文件及文件夹命令" class="headerlink" title="使用git bash 创建文件及文件夹命令"></a>使用git bash 创建文件及文件夹命令</h3><p>1.cd : 切换到哪个目录下， 如 cd e:\fff 切换 E 盘下面的fff 目录。<br>　　当我们用cd 进入文件夹时,我们可以使用 通配符*, cd f*, 如果E盘下只有一个f开头的文件夹,它就会进入到这个文件夹.<br>2.cd … 回退到上一个目录， 注意，cd 和两个点点…之间有一个空格。<br>3.pwd : 显示当前目录路径。<br>4.ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。<br>5.touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。<br>6.rm: 删除一个文件, rm index.js 就会把index.js文件删除.<br>7.mkdir: 新建一个目录,就是新建一个文件夹. 如mkdir src 新建src 文件夹.<br>8.rm -r : 删除一个文件夹, rm -r src 删除src目录， 好像不能用通配符。<br>9.mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下.<br>10.reset 清屏，把git bash命令窗口中的所有内容清空。</p><h3 id="Vim编辑器的撤销与恢复撤销操作"><a href="#Vim编辑器的撤销与恢复撤销操作" class="headerlink" title="Vim编辑器的撤销与恢复撤销操作"></a>Vim编辑器的撤销与恢复撤销操作</h3><ol><li><p>使用vim修改文档内容</p></li><li><p>按下Esc，回到命令模式</p></li><li><p>按下u，可以发现刚刚新加的内容全部消失了，vim编辑器底部还会显示“4 行被去掉的操作提示”，这就是撤销操作。</p></li><li><p>如果我们想回复到撤销前的内容，按下ctrl+r</p><p>可以看到刚刚被我们撤掉的四行内容又回来了，而且vim编辑器底部会显示“4 行被加入的操作提示”，这就是恢复撤销操作。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用git-bash-创建文件及文件夹命令&quot;&gt;&lt;a href=&quot;#使用git-bash-创建文件及文件夹命令&quot; class=&quot;headerlink&quot; title=&quot;使用git bash 创建文件及文件夹命令&quot;&gt;&lt;/a&gt;使用git bash 创建文件及文件夹命令&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>解决 java “错误：编码GBK 的不可映射字符”</title>
    <link href="http://lcdzzz.github.io/2020/11/24/jie-jue-java-cuo-wu-bian-ma-gbk-de-bu-ke-ying-she-zi-fu/"/>
    <id>http://lcdzzz.github.io/2020/11/24/jie-jue-java-cuo-wu-bian-ma-gbk-de-bu-ke-ying-she-zi-fu/</id>
    <published>2020-11-24T15:55:12.269Z</published>
    <updated>2020-11-28T13:36:36.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决-java-“错误：编码GBK-的不可映射字符”"><a href="#解决-java-“错误：编码GBK-的不可映射字符”" class="headerlink" title="解决 java “错误：编码GBK 的不可映射字符”"></a>解决 java “错误：编码GBK 的不可映射字符”</h2><ul><li><p>当java程序在idea上可以执行，但在cmd时报错：编码GBK 的不可映射字符时，通常都是因为GB2312编码的问题。</p></li><li><p>比如这个程序。在idea上运行时不会有问题的。用cmd运行时问题就出在第10行的<code>int xd =0//向导数</code>上，其中的“向导数”出了问题。</p><blockquote><pre><code>   Scanner in = new Scanner(System.in);   while (in.hasNext()) &#123;       int line = in.nextInt();       while (line-- &gt; 0) &#123;           int n = in.nextInt();//人数           int xd = 0;//向导数           int qx = n / 2;//抢险           int yl =(n-qx) *2 / 3;//医疗           int tx = n-qx - yl;//通讯           if (qx % 10 != 0) &#123;               xd = xd + qx / 10 + 1;           &#125; else &#123;               xd = xd + qx / 10;           &#125;           if (yl % 10 != 0) &#123;               xd = xd + yl / 10 + 1;           &#125; else &#123;               xd = xd + yl / 10;           &#125;           if (tx % 10 != 0) &#123;               xd = xd + tx / 10 + 1;           &#125; else &#123;               xd = xd + tx / 10;           &#125;           System.out.println(xd);       &#125;   &#125;</code></pre></blockquote></li><li><p>解决方法</p><ol><li><p>检查</p><p>查本机区域语言设置中文没有问题</p><p>需要把当前系统区域设置成中文（简体，中国）</p></li><li><p>在cmd中输入<code>javac -encoding UTF-8 HelloWorlewww.java</code></p><p>其中  <code>HelloWorlewww.java</code>就是你需要运行的java程序</p></li><li><p>记事本打开java源文件，另存为选择ANSI编码</p></li></ol><p>接下来重新用javac等操作编译，编译通过</p></li><li><p>说明：ANSI：美国国家标准协会，系统预设的标准文字储存格式。简体中文编码GB2312，实际上它是ＡＮＳＩ的一个代码页936</p><p>UTF-8：通用字集转换格式，这是为传输而设计的编码，2进制，以8位为单元对Unicode进行编码，如果使用只能在同类位元组内支持8个位元的重要资料一类的旧式传输媒体，可选择UTF-8格式。</p><p>在UTF-8里，英文字符仍然跟ASCII编码一样，因此原先的函数库可以继续使用。而中文的编码范围是在0080-07FF之间，因此是2个字节表示（但这两个字节和GB编码的两个字节是不同的），用专门的Unicode处理类可以对UTF编码进行处理。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解决-java-“错误：编码GBK-的不可映射字符”&quot;&gt;&lt;a href=&quot;#解决-java-“错误：编码GBK-的不可映射字符”&quot; class=&quot;headerlink&quot; title=&quot;解决 java “错误：编码GBK 的不可映射字符”&quot;&gt;&lt;/a&gt;解决 java </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo部分命令</title>
    <link href="http://lcdzzz.github.io/2020/11/24/hexo-bu-fen-ming-ling/"/>
    <id>http://lcdzzz.github.io/2020/11/24/hexo-bu-fen-ming-ling/</id>
    <published>2020-11-24T05:37:13.939Z</published>
    <updated>2020-11-25T00:30:33.033Z</updated>
    
    <content type="html"><![CDATA[<p><code>hexo clean&amp;&amp; hexo g &amp;&amp; hexo d</code></p><p><code>hexo clean</code>#清理各种缓存和旧文件</p><p><code>hexo g</code>#生成静态文件</p><p><code>hexo s</code>#开启服务器预览</p><p><code>hexo new &quot;postName&quot;</code> #新建文章</p><p><code>hexo new page &quot;pageName&quot;</code> #新建页面</p><p><code>hexo generate</code> #生成静态页面至public目录</p><p><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p><p><code>hexo deploy</code> #将.deploy目录部署到GitHub</p><p><code>hexo help</code>  # 查看帮助</p><p><code>hexo version</code>  #查看Hexo的版本</p><p><code>hexo deploy -g</code>  #生成加部署</p><p><code>hexo server -g</code>  #生成加预览</p><p>命令的简写</p><p><code>hexo n</code> == <code>hexo new</code> </p><p><code>hexo g</code> == <code>hexo generate</code>  #生成文件</p><p><code>hexo s</code> == <code>hexo server</code> #运行本地服务器</p><p><code>hexo d</code> == <code>hexo deploy</code> #上传到服务器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;hexo clean&amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hexo clean&lt;/code&gt;#清理各种缓存和旧文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hexo g&lt;/code&gt;#生成静态文件&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lcdzzz.github.io/2020/11/24/hello-world/"/>
    <id>http://lcdzzz.github.io/2020/11/24/hello-world/</id>
    <published>2020-11-24T05:37:13.934Z</published>
    <updated>2020-11-24T16:29:39.202Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><blockquote><p>$ hexo new “My New Post”</p></blockquote><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><blockquote><p>$ hexo server</p></blockquote><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><blockquote><p>$ hexo generate</p></blockquote><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><blockquote><p>$ hexo deploy</p></blockquote><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
